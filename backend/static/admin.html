<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - SimpleAI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0fdf4', 100: '#dcfce7', 200: '#bbf7d0', 300: '#86efac',
                            400: '#4ade80', 500: '#22c55e', 600: '#16a34a', 700: '#15803d',
                            800: '#166534', 900: '#14532d',
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="h-full">
    <div id="app" class="min-h-full">
        <!-- Loading state -->
        <div id="loading" class="flex items-center justify-center h-screen">
            <div class="text-gray-500">Loading...</div>
        </div>

        <!-- Login required -->
        <div id="login-required" class="hidden flex items-center justify-center h-screen">
            <div class="text-center">
                <h1 class="text-2xl font-bold text-gray-900 mb-4">SimpleAI Admin</h1>
                <p class="text-gray-600 mb-6">Please sign in to access the admin dashboard.</p>
                <button onclick="login()" class="bg-primary-600 hover:bg-primary-700 text-white font-medium py-2 px-4 rounded-md">
                    Sign in with OIDC
                </button>
            </div>
        </div>

        <!-- Main app -->
        <div id="main-app" class="hidden">
            <!-- Navigation -->
            <nav class="bg-gray-800">
                <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
                    <div class="flex h-16 items-center justify-between">
                        <div class="flex items-center">
                            <div class="flex-shrink-0">
                                <span class="text-white font-bold text-lg">SimpleAI</span>
                            </div>
                            <div class="ml-10 flex items-baseline space-x-4">
                                <a href="#dashboard" onclick="showPage('dashboard')" id="nav-dashboard" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Dashboard</a>
                                <a href="#runners" onclick="showPage('runners')" id="nav-runners" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Runners</a>
                                <a href="#models" onclick="showPage('models')" id="nav-models" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Models</a>
                                <a href="#users" onclick="showPage('users')" id="nav-users" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Users</a>
                                <a href="#requests" onclick="showPage('requests')" id="nav-requests" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Requests</a>
                            </div>
                        </div>
                        <div class="flex items-center space-x-4">
                            <span id="user-email" class="text-gray-300 text-sm"></span>
                            <button onclick="logout()" class="text-gray-300 hover:text-white text-sm">Logout</button>
                        </div>
                    </div>
                </div>
            </nav>

            <!-- Header -->
            <header class="bg-white shadow">
                <div class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
                    <div class="flex items-center justify-between">
                        <h1 id="page-title" class="text-3xl font-bold tracking-tight text-gray-900">Dashboard</h1>
                        <div id="refresh-indicator" class="text-xs text-gray-400">
                            <span id="last-updated"></span>
                            <span id="auto-refresh-badge" class="ml-2 inline-flex items-center rounded-full bg-green-100 px-2 py-0.5 text-xs font-medium text-green-800">Auto-refresh</span>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Main content -->
            <main>
                <div class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
                    <!-- Dashboard page -->
                    <div id="page-dashboard" class="page">
                        <div class="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Total Users</dt>
                                <dd id="stat-users" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Total Requests</dt>
                                <dd id="stat-requests" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Requests (24h)</dt>
                                <dd id="stat-requests-24h" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Connected Runners</dt>
                                <dd id="stat-runners" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                        </div>
                    </div>

                    <!-- Runners page -->
                    <div id="page-runners" class="page hidden">
                        <div id="runners-list" class="space-y-4"></div>
                    </div>

                    <!-- Models page -->
                    <div id="page-models" class="page hidden">
                        <div id="models-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="models-ul"></ul>
                        </div>
                    </div>

                    <!-- Users page -->
                    <div id="page-users" class="page hidden">
                        <div id="users-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="users-ul"></ul>
                        </div>
                    </div>

                    <!-- Requests page -->
                    <div id="page-requests" class="page hidden">
                        <div id="requests-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="requests-ul"></ul>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // OIDC Configuration
        const OIDC_ISSUER = 'https://auth.lelloman.com';
        const OIDC_CLIENT_ID = 'simple-ai';
        const REDIRECT_URI = window.location.origin + '/admin-ui';

        let accessToken = null;
        let userInfo = null;
        let currentPage = null;
        let refreshInterval = null;
        let runnerEventSource = null;
        const REFRESH_INTERVAL_MS = 5000; // Auto-refresh every 5 seconds (for non-SSE pages)

        // Token refresh state
        let refreshToken = null;
        let tokenExpiresAt = null;
        let inFlightRefresh = null;
        let lastRefreshTime = 0;
        let rateLimitedUntil = 0;
        const REFRESH_DEBOUNCE_MS = 5000;
        const TOKEN_REFRESH_BUFFER_SECONDS = 30;

        // Listen for storage changes from other tabs to sync tokens
        window.addEventListener('storage', (event) => {
            if (event.key === 'access_token' && event.newValue) {
                accessToken = event.newValue;
                console.log('Access token synced from another tab');
            } else if (event.key === 'refresh_token' && event.newValue) {
                refreshToken = event.newValue;
                console.log('Refresh token synced from another tab');
            } else if (event.key === 'token_expires_at' && event.newValue) {
                tokenExpiresAt = parseInt(event.newValue, 10);
            } else if (event.key === 'access_token' && !event.newValue) {
                // Another tab logged out
                console.log('Logged out from another tab');
                accessToken = null;
                refreshToken = null;
                tokenExpiresAt = null;
                showLogin();
            }
        });

        // PKCE helpers
        function generateRandomString(length) {
            const array = new Uint8Array(length);
            crypto.getRandomValues(array);
            return Array.from(array, b => b.toString(16).padStart(2, '0')).join('').slice(0, length);
        }

        async function sha256(plain) {
            const encoder = new TextEncoder();
            const data = encoder.encode(plain);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return hash;
        }

        function base64urlEncode(buffer) {
            const bytes = new Uint8Array(buffer);
            let str = '';
            for (const b of bytes) str += String.fromCharCode(b);
            return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        async function generateCodeChallenge(verifier) {
            const hash = await sha256(verifier);
            return base64urlEncode(hash);
        }

        // Token expiry helpers
        function parseTokenExpiry(token) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                if (payload.exp) {
                    return payload.exp * 1000; // Convert to milliseconds
                }
            } catch (e) {
                console.error('Failed to parse token expiry:', e);
            }
            return null;
        }

        function isTokenExpired() {
            if (!tokenExpiresAt) return true;
            return Date.now() >= tokenExpiresAt;
        }

        function isTokenExpiringSoon() {
            if (!tokenExpiresAt) return true;
            return Date.now() >= tokenExpiresAt - (TOKEN_REFRESH_BUFFER_SECONDS * 1000);
        }

        // Token refresh logic with coalescing and debouncing
        async function performRefresh() {
            // Always read refresh token from localStorage to handle multi-tab scenarios
            // where another tab may have rotated the token
            const currentRefreshToken = localStorage.getItem('refresh_token');
            if (!currentRefreshToken) {
                throw new Error('No refresh token available');
            }

            const response = await fetch(`${OIDC_ISSUER}/token`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    grant_type: 'refresh_token',
                    client_id: OIDC_CLIENT_ID,
                    refresh_token: currentRefreshToken,
                })
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Token refresh failed: ${response.status} ${text}`);
            }

            const tokens = await response.json();

            // Update tokens
            accessToken = tokens.access_token;
            localStorage.setItem('access_token', accessToken);

            if (tokens.refresh_token) {
                refreshToken = tokens.refresh_token;
                localStorage.setItem('refresh_token', refreshToken);
            }

            // Calculate expiry from response or parse from token
            if (tokens.expires_in) {
                tokenExpiresAt = Date.now() + (tokens.expires_in * 1000);
            } else {
                tokenExpiresAt = parseTokenExpiry(accessToken);
            }
            if (tokenExpiresAt) {
                localStorage.setItem('token_expires_at', tokenExpiresAt.toString());
            }

            return accessToken;
        }

        async function refreshTokens() {
            // Check rate limiting
            if (Date.now() < rateLimitedUntil) {
                throw new Error('Rate limited');
            }

            // Debounce rapid refresh attempts
            if (Date.now() - lastRefreshTime < REFRESH_DEBOUNCE_MS) {
                if (accessToken && !isTokenExpired()) {
                    return accessToken;
                }
            }

            // Coalesce concurrent refresh requests
            if (inFlightRefresh) {
                return inFlightRefresh;
            }

            inFlightRefresh = performRefresh()
                .then(token => {
                    lastRefreshTime = Date.now();
                    inFlightRefresh = null;
                    return token;
                })
                .catch(err => {
                    inFlightRefresh = null;
                    // Set rate limit backoff on failure (30 seconds)
                    rateLimitedUntil = Date.now() + 30000;
                    throw err;
                });

            return inFlightRefresh;
        }

        async function getValidAccessToken() {
            // If token is valid and not expiring soon, return it
            if (accessToken && !isTokenExpiringSoon()) {
                return accessToken;
            }

            // Try to refresh if we have a refresh token
            if (refreshToken) {
                try {
                    return await refreshTokens();
                } catch (e) {
                    console.error('Token refresh failed:', e);
                    return null;
                }
            }

            return accessToken;
        }

        // Check for authorization code in URL (after OIDC redirect)
        async function init() {
            const urlParams = new URLSearchParams(window.location.search);

            // Handle authorization code callback
            if (urlParams.has('code')) {
                const code = urlParams.get('code');
                const codeVerifier = sessionStorage.getItem('pkce_verifier');
                sessionStorage.removeItem('pkce_verifier');

                // Clean URL
                history.replaceState(null, '', window.location.pathname);

                if (codeVerifier) {
                    try {
                        // Exchange code for token
                        const tokenResponse = await fetch(`${OIDC_ISSUER}/token`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: new URLSearchParams({
                                grant_type: 'authorization_code',
                                client_id: OIDC_CLIENT_ID,
                                code: code,
                                redirect_uri: REDIRECT_URI,
                                code_verifier: codeVerifier,
                            })
                        });

                        if (tokenResponse.ok) {
                            const tokens = await tokenResponse.json();
                            accessToken = tokens.access_token;
                            localStorage.setItem('access_token', accessToken);

                            // Store refresh token if provided
                            if (tokens.refresh_token) {
                                refreshToken = tokens.refresh_token;
                                localStorage.setItem('refresh_token', refreshToken);
                            }

                            // Calculate and store token expiry
                            if (tokens.expires_in) {
                                tokenExpiresAt = Date.now() + (tokens.expires_in * 1000);
                            } else {
                                tokenExpiresAt = parseTokenExpiry(accessToken);
                            }
                            if (tokenExpiresAt) {
                                localStorage.setItem('token_expires_at', tokenExpiresAt.toString());
                            }
                        } else {
                            console.error('Token exchange failed:', await tokenResponse.text());
                        }
                    } catch (e) {
                        console.error('Token exchange error:', e);
                    }
                }
            } else {
                accessToken = localStorage.getItem('access_token');
                refreshToken = localStorage.getItem('refresh_token');
                const storedExpiry = localStorage.getItem('token_expires_at');
                if (storedExpiry) {
                    tokenExpiresAt = parseInt(storedExpiry, 10);
                }
            }

            // Proactively refresh if token is expiring soon
            if (accessToken && isTokenExpiringSoon() && refreshToken) {
                try {
                    await refreshTokens();
                } catch (e) {
                    console.error('Proactive token refresh failed:', e);
                }
            }

            if (accessToken) {
                // Validate token by making a request
                try {
                    const response = await fetch('/admin/runners', {
                        headers: { 'Authorization': `Bearer ${accessToken}` }
                    });

                    if (response.ok) {
                        // Parse JWT to get user info
                        const payload = JSON.parse(atob(accessToken.split('.')[1]));
                        userInfo = payload;
                        document.getElementById('user-email').textContent = payload.email || payload.sub;
                        showApp();
                        showPage(getPageFromHash());
                        return;
                    } else if (response.status === 401 || response.status === 403) {
                        // Try to refresh token before giving up
                        if (refreshToken) {
                            try {
                                await refreshTokens();
                                // Retry the validation after refresh
                                const retryResponse = await fetch('/admin/runners', {
                                    headers: { 'Authorization': `Bearer ${accessToken}` }
                                });
                                if (retryResponse.ok) {
                                    const payload = JSON.parse(atob(accessToken.split('.')[1]));
                                    userInfo = payload;
                                    document.getElementById('user-email').textContent = payload.email || payload.sub;
                                    showApp();
                                    showPage(getPageFromHash());
                                    return;
                                }
                            } catch (e) {
                                console.error('Token refresh during init failed:', e);
                            }
                        }
                        localStorage.removeItem('access_token');
                        localStorage.removeItem('refresh_token');
                        localStorage.removeItem('token_expires_at');
                        accessToken = null;
                        refreshToken = null;
                        tokenExpiresAt = null;
                    }
                } catch (e) {
                    console.error('Token validation failed:', e);
                }
            }

            showLoginRequired();
        }

        function showLoading() {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('login-required').classList.add('hidden');
            document.getElementById('main-app').classList.add('hidden');
        }

        function showLoginRequired() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('login-required').classList.remove('hidden');
            document.getElementById('main-app').classList.add('hidden');
        }

        function showApp() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('login-required').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');

            // Start SSE connection for real-time runner events
            if (!runnerEventSource) {
                runnerEventSource = new RunnerEventSource();
                runnerEventSource.connect();
            }
        }

        async function login() {
            // Generate PKCE code verifier and challenge
            const codeVerifier = generateRandomString(64);
            const codeChallenge = await generateCodeChallenge(codeVerifier);

            // Store verifier for token exchange
            sessionStorage.setItem('pkce_verifier', codeVerifier);

            const authUrl = `${OIDC_ISSUER}/authorize?` + new URLSearchParams({
                response_type: 'code',
                client_id: OIDC_CLIENT_ID,
                redirect_uri: REDIRECT_URI,
                scope: 'openid email profile offline_access',
                code_challenge: codeChallenge,
                code_challenge_method: 'S256',
            });
            window.location.href = authUrl;
        }

        function logout() {
            // Disconnect SSE
            if (runnerEventSource) {
                runnerEventSource.disconnect();
                runnerEventSource = null;
            }

            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
            localStorage.removeItem('token_expires_at');
            accessToken = null;
            refreshToken = null;
            tokenExpiresAt = null;
            inFlightRefresh = null;
            lastRefreshTime = 0;
            rateLimitedUntil = 0;
            showLoginRequired();
        }

        async function apiFetch(endpoint, retried = false) {
            // Get valid token (proactively refreshes if expiring soon)
            const token = await getValidAccessToken();
            if (!token) {
                logout();
                throw new Error('No valid token');
            }

            const response = await fetch(endpoint, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (!response.ok) {
                if (response.status === 401 && !retried) {
                    // Token might have expired, try to refresh
                    if (refreshToken) {
                        try {
                            await refreshTokens();
                            // Retry the request with new token
                            return apiFetch(endpoint, true);
                        } catch (e) {
                            console.error('Token refresh failed during API call:', e);
                            logout();
                            throw new Error('Session expired');
                        }
                    }
                    logout();
                    throw new Error('Unauthorized');
                }
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        }

        // Fetch API without triggering logout on auth failure (for background operations)
        async function apiFetchSilent(endpoint) {
            const token = await getValidAccessToken();
            if (!token) {
                throw new Error('No valid token');
            }

            const response = await fetch(endpoint, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        }

        // =================================================================
        // Utility functions
        // =================================================================

        // Escape HTML special characters to prevent XSS
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Escape string for use in HTML attributes
        function escapeAttr(str) {
            if (!str) return '';
            return str.replace(/[&<>"']/g, c => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            })[c]);
        }

        // =================================================================
        // Runner EventSource - Real-time SSE connection for runner events
        // =================================================================
        class RunnerEventSource {
            constructor() {
                this.eventSource = null;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectAttempts = 0;
            }

            async connect() {
                // Close existing connection if any
                this.disconnect();

                try {
                    const token = await getValidAccessToken();
                    if (!token) {
                        console.error('No token available for SSE connection');
                        return;
                    }

                    const url = `/admin/runners/events?token=${encodeURIComponent(token)}`;
                    this.eventSource = new EventSource(url);

                    this.eventSource.onopen = () => {
                        console.log('SSE connection established');
                        this.reconnectDelay = 1000;
                        this.reconnectAttempts = 0;
                        this.updateConnectionBadge(true);
                    };

                    this.eventSource.onerror = async (event) => {
                        console.error('SSE connection error', event);
                        this.updateConnectionBadge(false);

                        // EventSource will auto-reconnect, but we need to handle token refresh
                        if (this.eventSource.readyState === EventSource.CLOSED) {
                            this.eventSource = null;
                            await this.scheduleReconnect();
                        }
                    };

                    // Handle runner events
                    this.eventSource.addEventListener('runner_connected', (event) => {
                        const data = JSON.parse(event.data);
                        console.log('Runner connected:', data);
                        this.handleRunnerConnected(data);
                    });

                    this.eventSource.addEventListener('runner_disconnected', (event) => {
                        const data = JSON.parse(event.data);
                        console.log('Runner disconnected:', data);
                        this.handleRunnerDisconnected(data);
                    });

                    this.eventSource.addEventListener('runner_status_changed', (event) => {
                        const data = JSON.parse(event.data);
                        console.log('Runner status changed:', data);
                        this.handleRunnerStatusChanged(data);
                    });
                } catch (e) {
                    console.error('Failed to establish SSE connection:', e);
                    await this.scheduleReconnect();
                }
            }

            async scheduleReconnect() {
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);
                console.log(`Scheduling SSE reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);

                // Try to refresh token before reconnecting
                if (refreshToken) {
                    try {
                        await refreshTokens();
                    } catch (e) {
                        console.error('Token refresh failed before SSE reconnect:', e);
                    }
                }

                setTimeout(() => this.connect(), delay);
            }

            disconnect() {
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }
                this.updateConnectionBadge(false);
            }

            updateConnectionBadge(connected) {
                const badge = document.getElementById('auto-refresh-badge');
                if (badge) {
                    if (connected) {
                        badge.textContent = 'Live';
                        badge.classList.remove('bg-yellow-100', 'text-yellow-800', 'bg-gray-100', 'text-gray-600');
                        badge.classList.add('bg-green-100', 'text-green-800');
                    } else {
                        badge.textContent = 'Reconnecting...';
                        badge.classList.remove('bg-green-100', 'text-green-800', 'bg-gray-100', 'text-gray-600');
                        badge.classList.add('bg-yellow-100', 'text-yellow-800');
                    }
                }
            }

            async handleRunnerConnected(data) {
                // Fetch full runner data to get mac_address, http_base_url, etc.
                // Use silent fetch to avoid triggering logout on auth errors
                try {
                    const runnersData = await apiFetchSilent('/admin/runners');
                    const fullRunner = runnersData.runners.find(r => r.id === data.runner_id);
                    if (fullRunner) {
                        upsertRunnerCard(data.runner_id, fullRunner);
                    } else {
                        // Fallback to event data if runner not found in list
                        this.upsertWithEventData(data);
                    }
                } catch (e) {
                    console.error('Failed to fetch runner details:', e);
                    // Use event data as fallback
                    this.upsertWithEventData(data);
                }

                // Update dashboard runner count if viewing dashboard
                // (dashboard polls so it will update on next refresh)
            }

            upsertWithEventData(data) {
                const runner = {
                    id: data.runner_id,
                    name: data.name,
                    machine_type: data.machine_type,
                    health: data.health,
                    loaded_models: data.loaded_models,
                    is_online: true,
                    connected_at: new Date().toISOString(),
                    last_heartbeat: new Date().toISOString(),
                    mac_address: null,
                    http_base_url: null
                };
                upsertRunnerCard(data.runner_id, runner);
            }

            handleRunnerDisconnected(data) {
                markRunnerOffline(data.runner_id);
                // Dashboard polls so it will update on next refresh
            }

            handleRunnerStatusChanged(data) {
                updateRunnerCard(data.runner_id, {
                    health: data.health,
                    loaded_models: data.loaded_models
                });
            }
        }

        // Helper function to render a single runner card
        function renderRunnerCard(runner) {
            const safeId = escapeAttr(runner.id);
            const safeName = escapeHtml(runner.name);
            const safeHealth = escapeHtml(runner.health);
            const safeMachineType = escapeHtml(runner.machine_type || 'N/A');
            const safeMacAddress = escapeHtml(runner.mac_address || 'N/A');
            const safeHttpUrl = escapeHtml(runner.http_base_url || 'N/A');

            return `
                <div id="runner-card-${safeId}" class="rounded-lg shadow p-6 ${runner.is_online ? 'bg-white' : 'bg-gray-50 border border-gray-200'}" data-runner-id="${safeId}" data-is-online="${runner.is_online}" data-mac-address="${escapeAttr(runner.mac_address || '')}">
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <h3 class="text-lg font-medium ${runner.is_online ? 'text-gray-900' : 'text-gray-500'}">${safeName}</h3>
                            <p class="text-sm text-gray-500">${safeId}</p>
                        </div>
                        <div class="flex items-center space-x-2">
                            ${!runner.is_online && runner.mac_address ? `
                                <button onclick="wakeRunner('${safeId}')"
                                        class="inline-flex items-center rounded-md bg-blue-600 px-3 py-1 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                                        id="wake-btn-${safeId}">
                                    Wake
                                </button>
                            ` : ''}
                            <span class="runner-health-badge inline-flex items-center rounded-full px-3 py-1 text-sm font-medium ${
                                runner.health === 'Healthy' ? 'bg-green-100 text-green-800' :
                                runner.health === 'Degraded' ? 'bg-yellow-100 text-yellow-800' :
                                runner.health === 'Offline' ? 'bg-gray-100 text-gray-600' :
                                'bg-red-100 text-red-800'
                            }">${safeHealth}</span>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="text-gray-500">Machine Type:</span>
                            <span class="ml-2 ${runner.is_online ? 'text-gray-900' : 'text-gray-600'}">${safeMachineType}</span>
                        </div>
                        <div>
                            <span class="text-gray-500">MAC Address:</span>
                            <span class="ml-2 ${runner.is_online ? 'text-gray-900' : 'text-gray-600'}">${safeMacAddress}</span>
                        </div>
                        ${runner.is_online ? `
                            <div>
                                <span class="text-gray-500">HTTP URL:</span>
                                <span class="ml-2 text-gray-900">${safeHttpUrl}</span>
                            </div>
                            <div>
                                <span class="text-gray-500">Connected:</span>
                                <span class="ml-2 text-gray-900">${runner.connected_at ? new Date(runner.connected_at).toLocaleString() : 'N/A'}</span>
                            </div>
                        ` : ''}
                        <div>
                            <span class="text-gray-500">${runner.is_online ? 'Last Heartbeat' : 'Last Seen'}:</span>
                            <span class="ml-2 ${runner.is_online ? 'text-gray-900' : 'text-gray-600'}">${runner.last_heartbeat ? new Date(runner.last_heartbeat).toLocaleString() : 'N/A'}</span>
                        </div>
                    </div>
                    <div class="runner-models-section mt-4 ${runner.loaded_models && runner.loaded_models.length > 0 ? '' : 'hidden'}">
                        <span class="text-sm text-gray-500">Loaded Models:</span>
                        <div class="runner-models mt-1 flex flex-wrap gap-2">
                            ${(runner.loaded_models || []).map(m => `<span class="inline-flex items-center rounded-md bg-primary-100 px-2 py-1 text-xs font-medium text-primary-700">${escapeHtml(m)}</span>`).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Upsert (insert or update) a runner card
        function upsertRunnerCard(runnerId, runner) {
            const container = document.getElementById('runners-list');
            if (!container) return;

            const existingCard = document.getElementById(`runner-card-${runnerId}`);
            if (existingCard) {
                // Replace existing card
                existingCard.outerHTML = renderRunnerCard(runner);
            } else {
                // Check if we have the "No runners" message
                const noRunnersMsg = container.querySelector('.text-gray-500.text-center');
                if (noRunnersMsg) {
                    container.innerHTML = '';
                }
                // Insert new card at the top
                container.insertAdjacentHTML('afterbegin', renderRunnerCard(runner));
            }
        }

        // Mark a runner as offline (grey out and change badge)
        function markRunnerOffline(runnerId) {
            const card = document.getElementById(`runner-card-${runnerId}`);
            if (!card) return;

            // Update styling
            card.classList.remove('bg-white');
            card.classList.add('bg-gray-50', 'border', 'border-gray-200');
            card.dataset.isOnline = 'false';

            // Update name styling
            const nameEl = card.querySelector('h3');
            if (nameEl) {
                nameEl.classList.remove('text-gray-900');
                nameEl.classList.add('text-gray-500');
            }

            // Update health badge to Offline
            const badge = card.querySelector('.runner-health-badge');
            if (badge) {
                badge.className = 'runner-health-badge inline-flex items-center rounded-full px-3 py-1 text-sm font-medium bg-gray-100 text-gray-600';
                badge.textContent = 'Offline';

                // Add Wake button if runner has MAC address and button doesn't exist
                const macAddress = card.dataset.macAddress;
                const existingWakeBtn = card.querySelector(`#wake-btn-${runnerId}`);
                if (macAddress && !existingWakeBtn) {
                    const safeId = escapeAttr(runnerId);
                    const wakeBtn = `<button onclick="wakeRunner('${safeId}')"
                            class="inline-flex items-center rounded-md bg-blue-600 px-3 py-1 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                            id="wake-btn-${safeId}">
                        Wake
                    </button>`;
                    badge.insertAdjacentHTML('beforebegin', wakeBtn);
                }
            }

            // Hide loaded models section
            const modelsSection = card.querySelector('.runner-models-section');
            if (modelsSection) {
                modelsSection.classList.add('hidden');
            }
        }

        // Update a runner card's health and loaded models
        function updateRunnerCard(runnerId, updates) {
            const card = document.getElementById(`runner-card-${runnerId}`);
            if (!card) return;

            if (updates.health) {
                const badge = card.querySelector('.runner-health-badge');
                if (badge) {
                    badge.className = 'runner-health-badge inline-flex items-center rounded-full px-3 py-1 text-sm font-medium ' +
                        (updates.health === 'Healthy' ? 'bg-green-100 text-green-800' :
                         updates.health === 'Degraded' ? 'bg-yellow-100 text-yellow-800' :
                         updates.health === 'Offline' ? 'bg-gray-100 text-gray-600' :
                         'bg-red-100 text-red-800');
                    badge.textContent = updates.health;
                }
            }

            if (updates.loaded_models !== undefined) {
                const modelsSection = card.querySelector('.runner-models-section');
                const modelsContainer = card.querySelector('.runner-models');
                if (modelsSection && modelsContainer) {
                    if (updates.loaded_models.length > 0) {
                        modelsSection.classList.remove('hidden');
                        modelsContainer.innerHTML = updates.loaded_models
                            .map(m => `<span class="inline-flex items-center rounded-md bg-primary-100 px-2 py-1 text-xs font-medium text-primary-700">${escapeHtml(m)}</span>`)
                            .join('');
                    } else {
                        modelsSection.classList.add('hidden');
                    }
                }
            }
        }

        function showPage(page) {
            // Stop any existing refresh interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }

            currentPage = page;

            // Update nav
            document.querySelectorAll('.nav-link').forEach(el => {
                el.classList.remove('bg-gray-900', 'text-white');
                el.classList.add('text-gray-300', 'hover:bg-gray-700', 'hover:text-white');
            });
            const activeNav = document.getElementById(`nav-${page}`);
            if (activeNav) {
                activeNav.classList.add('bg-gray-900', 'text-white');
                activeNav.classList.remove('text-gray-300', 'hover:bg-gray-700', 'hover:text-white');
            }

            // Update title
            const titles = {
                dashboard: 'Dashboard',
                runners: 'Runners',
                models: 'Models',
                users: 'Users',
                requests: 'Requests'
            };
            document.getElementById('page-title').textContent = titles[page] || page;

            // Show page
            document.querySelectorAll('.page').forEach(el => el.classList.add('hidden'));
            document.getElementById(`page-${page}`).classList.remove('hidden');

            // Load data
            loadPageData(page);

            // Set up auto-refresh for pages that benefit from it
            // Note: 'runners' page uses SSE for real-time updates, not polling
            if (['dashboard', 'models'].includes(page)) {
                refreshInterval = setInterval(() => loadPageData(page), REFRESH_INTERVAL_MS);
            }
        }

        function loadPageData(page) {
            // Update last-updated timestamp
            document.getElementById('last-updated').textContent = `Updated: ${new Date().toLocaleTimeString()}`;

            // Show/hide auto-refresh badge based on page
            const badge = document.getElementById('auto-refresh-badge');
            if (['dashboard', 'runners', 'models'].includes(page)) {
                badge.classList.remove('hidden');
                // For runners page, badge text is controlled by SSE connection state
                // For other pages, show "Auto-refresh" badge
                if (page !== 'runners') {
                    badge.textContent = 'Auto-refresh';
                    badge.classList.remove('bg-yellow-100', 'text-yellow-800');
                    badge.classList.add('bg-green-100', 'text-green-800');
                }
            } else {
                badge.classList.add('hidden');
            }

            if (page === 'dashboard') loadDashboard();
            else if (page === 'runners') loadRunners();
            else if (page === 'models') loadModels();
            else if (page === 'users') loadUsers();
            else if (page === 'requests') loadRequests();
        }

        async function loadDashboard() {
            try {
                const [runnersData] = await Promise.all([
                    apiFetch('/admin/runners')
                ]);
                document.getElementById('stat-runners').textContent = runnersData.total;

                // Try to load stats (may not have dedicated endpoint)
                document.getElementById('stat-users').textContent = '-';
                document.getElementById('stat-requests').textContent = '-';
                document.getElementById('stat-requests-24h').textContent = '-';
            } catch (e) {
                console.error('Failed to load dashboard:', e);
            }
        }

        async function loadRunners() {
            try {
                const data = await apiFetch('/admin/runners');
                const container = document.getElementById('runners-list');

                if (data.runners.length === 0) {
                    container.innerHTML = '<div class="bg-white rounded-lg shadow p-6 text-gray-500 text-center">No runners registered</div>';
                    return;
                }

                container.innerHTML = data.runners.map(runner => renderRunnerCard(runner)).join('');
            } catch (e) {
                console.error('Failed to load runners:', e);
            }
        }

        async function wakeRunner(runnerId) {
            const btn = document.getElementById(`wake-btn-${runnerId}`);
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Waking...';
            }

            try {
                const token = await getValidAccessToken();
                if (!token) {
                    logout();
                    return;
                }

                const response = await fetch(`/admin/runners/${encodeURIComponent(runnerId)}/wake`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                // Handle 401 with retry
                if (response.status === 401 && refreshToken) {
                    try {
                        await refreshTokens();
                        return wakeRunner(runnerId); // Retry
                    } catch (e) {
                        logout();
                        return;
                    }
                }

                const result = await response.json();

                if (response.ok && result.success) {
                    if (btn) {
                        btn.textContent = 'Sent!';
                        btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                        btn.classList.add('bg-green-600');
                    }
                    // Refresh runners list after a short delay
                    setTimeout(() => loadRunners(), 2000);
                } else {
                    alert(`Failed to wake runner: ${result.message}`);
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'Wake';
                    }
                }
            } catch (e) {
                console.error('Failed to wake runner:', e);
                alert('Failed to send wake request');
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Wake';
                }
            }
        }

        async function loadModels() {
            try {
                const data = await apiFetch('/admin/models');
                const ul = document.getElementById('models-ul');

                if (data.models.length === 0) {
                    ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">No models available</li>';
                    return;
                }

                ul.innerHTML = data.models.map(model => `
                    <li class="px-4 py-4">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="text-sm font-medium text-gray-900">${model.id}</p>
                                <p class="text-xs text-gray-500">
                                    ${model.quantization ? `Quant: ${model.quantization}` : ''}
                                    ${model.context_length ? ` | Context: ${model.context_length}` : ''}
                                    ${model.size_bytes ? ` | Size: ${(model.size_bytes / 1024 / 1024 / 1024).toFixed(1)} GB` : ''}
                                </p>
                            </div>
                            <div class="flex items-center space-x-3">
                                <span class="inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${
                                    model.loaded ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-600'
                                }">${model.loaded ? 'Loaded' : 'Not loaded'}</span>
                                <span class="text-xs text-gray-500" title="Runners with model in memory">${model.runners.length} loaded</span>
                                <span class="text-xs text-gray-400" title="Runners with model on disk">${model.available_on ? model.available_on.length : 0} available</span>
                            </div>
                        </div>
                    </li>
                `).join('');
            } catch (e) {
                console.error('Failed to load models:', e);
            }
        }

        async function loadUsers() {
            const ul = document.getElementById('users-ul');
            ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">User list requires server-side rendering (use /admin/users with token)</li>';
        }

        async function loadRequests() {
            const ul = document.getElementById('requests-ul');
            ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">Request list requires server-side rendering (use /admin/requests with token)</li>';
        }

        // Handle hash-based navigation
        function getPageFromHash() {
            const hash = window.location.hash.slice(1); // Remove the #
            const validPages = ['dashboard', 'runners', 'models', 'users', 'requests'];
            return validPages.includes(hash) ? hash : 'dashboard';
        }

        // Listen for hash changes (back/forward navigation)
        window.addEventListener('hashchange', () => {
            if (accessToken) {
                showPage(getPageFromHash());
            }
        });

        // Initialize on page load
        init();
    </script>
</body>
</html>
