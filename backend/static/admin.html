<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - SimpleAI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0fdf4', 100: '#dcfce7', 200: '#bbf7d0', 300: '#86efac',
                            400: '#4ade80', 500: '#22c55e', 600: '#16a34a', 700: '#15803d',
                            800: '#166534', 900: '#14532d',
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="h-full">
    <div id="app" class="min-h-full">
        <!-- Loading state -->
        <div id="loading" class="flex items-center justify-center h-screen">
            <div class="text-gray-500">Loading...</div>
        </div>

        <!-- Login required -->
        <div id="login-required" class="hidden flex items-center justify-center h-screen">
            <div class="text-center">
                <h1 class="text-2xl font-bold text-gray-900 mb-4">SimpleAI Admin</h1>
                <p class="text-gray-600 mb-6">Please sign in to access the admin dashboard.</p>
                <button onclick="login()" class="bg-primary-600 hover:bg-primary-700 text-white font-medium py-2 px-4 rounded-md">
                    Sign in with OIDC
                </button>
            </div>
        </div>

        <!-- Main app -->
        <div id="main-app" class="hidden">
            <!-- Navigation -->
            <nav class="bg-gray-800">
                <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
                    <div class="flex h-16 items-center justify-between">
                        <div class="flex items-center">
                            <div class="flex-shrink-0">
                                <span class="text-white font-bold text-lg">SimpleAI</span>
                            </div>
                            <div class="ml-10 flex items-baseline space-x-4">
                                <a href="#dashboard" onclick="showPage('dashboard')" id="nav-dashboard" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Dashboard</a>
                                <a href="#runners" onclick="showPage('runners')" id="nav-runners" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Runners</a>
                                <a href="#models" onclick="showPage('models')" id="nav-models" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Models</a>
                                <a href="#users" onclick="showPage('users')" id="nav-users" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Users</a>
                                <a href="#requests" onclick="showPage('requests')" id="nav-requests" class="nav-link rounded-md px-3 py-2 text-sm font-medium">Requests</a>
                                <a href="#apikeys" onclick="showPage('apikeys')" id="nav-apikeys" class="nav-link rounded-md px-3 py-2 text-sm font-medium">API Keys</a>
                            </div>
                        </div>
                        <div class="flex items-center space-x-4">
                            <span id="user-email" class="text-gray-300 text-sm"></span>
                            <button onclick="logout()" class="text-gray-300 hover:text-white text-sm">Logout</button>
                        </div>
                    </div>
                </div>
            </nav>

            <!-- Header -->
            <header class="bg-white shadow">
                <div class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
                    <div class="flex items-center justify-between">
                        <h1 id="page-title" class="text-3xl font-bold tracking-tight text-gray-900">Dashboard</h1>
                        <div id="refresh-indicator" class="text-xs text-gray-400">
                            <span id="last-updated"></span>
                            <span id="auto-refresh-badge" class="ml-2 inline-flex items-center rounded-full bg-green-100 px-2 py-0.5 text-xs font-medium text-green-800">Auto-refresh</span>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Main content -->
            <main>
                <div class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
                    <!-- Dashboard page -->
                    <div id="page-dashboard" class="page">
                        <div class="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Total Users</dt>
                                <dd id="stat-users" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Total Requests</dt>
                                <dd id="stat-requests" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Requests (24h)</dt>
                                <dd id="stat-requests-24h" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                            <div class="overflow-hidden rounded-lg bg-white px-4 py-5 shadow sm:p-6">
                                <dt class="truncate text-sm font-medium text-gray-500">Connected Runners</dt>
                                <dd id="stat-runners" class="mt-1 text-3xl font-semibold tracking-tight text-gray-900">-</dd>
                            </div>
                        </div>
                    </div>

                    <!-- Runners page -->
                    <div id="page-runners" class="page hidden">
                        <div id="runners-list" class="space-y-4"></div>
                    </div>

                    <!-- Models page -->
                    <div id="page-models" class="page hidden">
                        <div id="models-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="models-ul"></ul>
                        </div>
                    </div>

                    <!-- Users page -->
                    <div id="page-users" class="page hidden">
                        <div id="users-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="users-ul"></ul>
                        </div>
                    </div>

                    <!-- Requests page -->
                    <div id="page-requests" class="page hidden">
                        <div id="requests-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="requests-ul"></ul>
                        </div>
                    </div>

                    <!-- API Keys page -->
                    <div id="page-apikeys" class="page hidden">
                        <!-- Create API Key Form -->
                        <div class="bg-white shadow sm:rounded-lg mb-6">
                            <div class="px-4 py-5 sm:p-6">
                                <h3 class="text-lg font-medium leading-6 text-gray-900">Create API Key</h3>
                                <div class="mt-4 grid grid-cols-1 gap-4 sm:grid-cols-3">
                                    <div>
                                        <label for="api-key-user" class="block text-sm font-medium text-gray-700">User</label>
                                        <select id="api-key-user" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500 sm:text-sm border p-2">
                                            <option value="">Select a user...</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label for="api-key-name" class="block text-sm font-medium text-gray-700">Key Name</label>
                                        <input type="text" id="api-key-name" placeholder="e.g., Chrome Extension" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-primary-500 focus:ring-primary-500 sm:text-sm border p-2">
                                    </div>
                                    <div class="flex items-end">
                                        <button onclick="createApiKey()" class="inline-flex items-center rounded-md bg-primary-600 px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-primary-500">
                                            Create Key
                                        </button>
                                    </div>
                                </div>
                                <!-- Show newly created key -->
                                <div id="new-key-display" class="hidden mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-md">
                                    <p class="text-sm font-medium text-yellow-800">Copy your API key now - it won't be shown again!</p>
                                    <div class="mt-2 flex items-center space-x-2">
                                        <code id="new-key-value" class="flex-1 p-2 bg-white border rounded text-sm font-mono"></code>
                                        <button onclick="copyApiKey()" class="px-3 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 text-sm">Copy</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- API Keys List -->
                        <div id="apikeys-list" class="overflow-hidden bg-white shadow sm:rounded-md">
                            <ul role="list" class="divide-y divide-gray-200" id="apikeys-ul"></ul>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // OIDC Configuration
        const OIDC_ISSUER = 'https://auth.lelloman.com';
        const OIDC_CLIENT_ID = 'simple-ai';
        const REDIRECT_URI = window.location.origin + '/admin-ui';

        let accessToken = null;
        let userInfo = null;
        let currentPage = null;
        let refreshInterval = null;
        let runnerWebSocket = null;

        // Reactive state (populated via WebSocket)
        let runnersState = [];
        let modelsState = [];
        let statsState = { total_users: 0, total_requests: 0, requests_24h: 0, total_tokens: 0 };

        // Token refresh state
        let refreshToken = null;
        let tokenExpiresAt = null;
        let inFlightRefresh = null;
        let lastRefreshTime = 0;
        let rateLimitedUntil = 0;
        const REFRESH_DEBOUNCE_MS = 5000;
        const TOKEN_REFRESH_BUFFER_SECONDS = 30;

        // Listen for storage changes from other tabs to sync tokens
        window.addEventListener('storage', (event) => {
            if (event.key === 'access_token' && event.newValue) {
                accessToken = event.newValue;
                console.log('Access token synced from another tab');
            } else if (event.key === 'refresh_token' && event.newValue) {
                refreshToken = event.newValue;
                console.log('Refresh token synced from another tab');
            } else if (event.key === 'token_expires_at' && event.newValue) {
                tokenExpiresAt = parseInt(event.newValue, 10);
            } else if (event.key === 'access_token' && !event.newValue) {
                // Another tab logged out
                console.log('Logged out from another tab');
                accessToken = null;
                refreshToken = null;
                tokenExpiresAt = null;
                showLogin();
            }
        });

        // PKCE helpers
        function generateRandomString(length) {
            const array = new Uint8Array(length);
            crypto.getRandomValues(array);
            return Array.from(array, b => b.toString(16).padStart(2, '0')).join('').slice(0, length);
        }

        async function sha256(plain) {
            const encoder = new TextEncoder();
            const data = encoder.encode(plain);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return hash;
        }

        function base64urlEncode(buffer) {
            const bytes = new Uint8Array(buffer);
            let str = '';
            for (const b of bytes) str += String.fromCharCode(b);
            return btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        async function generateCodeChallenge(verifier) {
            const hash = await sha256(verifier);
            return base64urlEncode(hash);
        }

        // Token expiry helpers
        function parseTokenExpiry(token) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                if (payload.exp) {
                    return payload.exp * 1000; // Convert to milliseconds
                }
            } catch (e) {
                console.error('Failed to parse token expiry:', e);
            }
            return null;
        }

        function isTokenExpired() {
            if (!tokenExpiresAt) return true;
            return Date.now() >= tokenExpiresAt;
        }

        function isTokenExpiringSoon() {
            if (!tokenExpiresAt) return true;
            return Date.now() >= tokenExpiresAt - (TOKEN_REFRESH_BUFFER_SECONDS * 1000);
        }

        // Token refresh logic with coalescing and debouncing
        async function performRefresh() {
            // Always read refresh token from localStorage to handle multi-tab scenarios
            // where another tab may have rotated the token
            const currentRefreshToken = localStorage.getItem('refresh_token');
            if (!currentRefreshToken) {
                throw new Error('No refresh token available');
            }

            const response = await fetch(`${OIDC_ISSUER}/token`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams({
                    grant_type: 'refresh_token',
                    client_id: OIDC_CLIENT_ID,
                    refresh_token: currentRefreshToken,
                })
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`Token refresh failed: ${response.status} ${text}`);
            }

            const tokens = await response.json();

            // Update tokens
            accessToken = tokens.access_token;
            localStorage.setItem('access_token', accessToken);

            if (tokens.refresh_token) {
                refreshToken = tokens.refresh_token;
                localStorage.setItem('refresh_token', refreshToken);
            }

            // Calculate expiry from response or parse from token
            if (tokens.expires_in) {
                tokenExpiresAt = Date.now() + (tokens.expires_in * 1000);
            } else {
                tokenExpiresAt = parseTokenExpiry(accessToken);
            }
            if (tokenExpiresAt) {
                localStorage.setItem('token_expires_at', tokenExpiresAt.toString());
            }

            // Notify WebSocket of new token (re-authenticate mid-connection)
            if (runnerWebSocket?.ws?.readyState === WebSocket.OPEN) {
                runnerWebSocket.refreshAuth();
            }

            return accessToken;
        }

        async function refreshTokens() {
            // Check rate limiting
            if (Date.now() < rateLimitedUntil) {
                throw new Error('Rate limited');
            }

            // Debounce rapid refresh attempts
            if (Date.now() - lastRefreshTime < REFRESH_DEBOUNCE_MS) {
                if (accessToken && !isTokenExpired()) {
                    return accessToken;
                }
            }

            // Coalesce concurrent refresh requests
            if (inFlightRefresh) {
                return inFlightRefresh;
            }

            inFlightRefresh = performRefresh()
                .then(token => {
                    lastRefreshTime = Date.now();
                    inFlightRefresh = null;
                    return token;
                })
                .catch(err => {
                    inFlightRefresh = null;
                    // Set rate limit backoff on failure (30 seconds)
                    rateLimitedUntil = Date.now() + 30000;
                    throw err;
                });

            return inFlightRefresh;
        }

        async function getValidAccessToken() {
            // If token is valid and not expiring soon, return it
            if (accessToken && !isTokenExpiringSoon()) {
                return accessToken;
            }

            // Try to refresh if we have a refresh token
            if (refreshToken) {
                try {
                    return await refreshTokens();
                } catch (e) {
                    console.error('Token refresh failed:', e);
                    return null;
                }
            }

            return accessToken;
        }

        // Check for authorization code in URL (after OIDC redirect)
        async function init() {
            const urlParams = new URLSearchParams(window.location.search);

            // Handle authorization code callback
            if (urlParams.has('code')) {
                const code = urlParams.get('code');
                const codeVerifier = sessionStorage.getItem('pkce_verifier');
                sessionStorage.removeItem('pkce_verifier');

                // Clean URL
                history.replaceState(null, '', window.location.pathname);

                if (codeVerifier) {
                    try {
                        // Exchange code for token
                        const tokenResponse = await fetch(`${OIDC_ISSUER}/token`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: new URLSearchParams({
                                grant_type: 'authorization_code',
                                client_id: OIDC_CLIENT_ID,
                                code: code,
                                redirect_uri: REDIRECT_URI,
                                code_verifier: codeVerifier,
                            })
                        });

                        if (tokenResponse.ok) {
                            const tokens = await tokenResponse.json();
                            accessToken = tokens.access_token;
                            localStorage.setItem('access_token', accessToken);

                            // Store refresh token if provided
                            if (tokens.refresh_token) {
                                refreshToken = tokens.refresh_token;
                                localStorage.setItem('refresh_token', refreshToken);
                            }

                            // Calculate and store token expiry
                            if (tokens.expires_in) {
                                tokenExpiresAt = Date.now() + (tokens.expires_in * 1000);
                            } else {
                                tokenExpiresAt = parseTokenExpiry(accessToken);
                            }
                            if (tokenExpiresAt) {
                                localStorage.setItem('token_expires_at', tokenExpiresAt.toString());
                            }
                        } else {
                            console.error('Token exchange failed:', await tokenResponse.text());
                        }
                    } catch (e) {
                        console.error('Token exchange error:', e);
                    }
                }
            } else {
                accessToken = localStorage.getItem('access_token');
                refreshToken = localStorage.getItem('refresh_token');
                const storedExpiry = localStorage.getItem('token_expires_at');
                if (storedExpiry) {
                    tokenExpiresAt = parseInt(storedExpiry, 10);
                }
            }

            // Proactively refresh if token is expiring soon
            if (accessToken && isTokenExpiringSoon() && refreshToken) {
                try {
                    await refreshTokens();
                } catch (e) {
                    console.error('Proactive token refresh failed:', e);
                }
            }

            if (accessToken) {
                // We have tokens - show the app and let WebSocket handle authentication.
                // If WebSocket auth fails, it will trigger logout.
                try {
                    const payload = JSON.parse(atob(accessToken.split('.')[1]));
                    userInfo = payload;
                    document.getElementById('user-email').textContent = payload.email || payload.sub;
                    showApp();
                    showPage(getPageFromHash());
                    return;
                } catch (e) {
                    // Token is malformed - clear it
                    console.error('Failed to parse token:', e);
                    localStorage.removeItem('access_token');
                    localStorage.removeItem('refresh_token');
                    localStorage.removeItem('token_expires_at');
                    accessToken = null;
                    refreshToken = null;
                    tokenExpiresAt = null;
                }
            }

            showLoginRequired();
        }

        function showLoading() {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('login-required').classList.add('hidden');
            document.getElementById('main-app').classList.add('hidden');
        }

        function showLoginRequired() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('login-required').classList.remove('hidden');
            document.getElementById('main-app').classList.add('hidden');
        }

        function showApp() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('login-required').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');

            // Start WebSocket connection for real-time runner events
            if (!runnerWebSocket) {
                runnerWebSocket = new RunnerWebSocket();
                runnerWebSocket.connect();
            }
        }

        async function login() {
            // Generate PKCE code verifier and challenge
            const codeVerifier = generateRandomString(64);
            const codeChallenge = await generateCodeChallenge(codeVerifier);

            // Store verifier for token exchange
            sessionStorage.setItem('pkce_verifier', codeVerifier);

            const authUrl = `${OIDC_ISSUER}/authorize?` + new URLSearchParams({
                response_type: 'code',
                client_id: OIDC_CLIENT_ID,
                redirect_uri: REDIRECT_URI,
                scope: 'openid email profile offline_access',
                code_challenge: codeChallenge,
                code_challenge_method: 'S256',
            });
            window.location.href = authUrl;
        }

        function logout() {
            // Disconnect WebSocket
            if (runnerWebSocket) {
                runnerWebSocket.disconnect();
                runnerWebSocket = null;
            }

            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
            localStorage.removeItem('token_expires_at');
            accessToken = null;
            refreshToken = null;
            tokenExpiresAt = null;
            inFlightRefresh = null;
            lastRefreshTime = 0;
            rateLimitedUntil = 0;
            showLoginRequired();
        }

        async function apiFetch(endpoint, retried = false) {
            // Get valid token (proactively refreshes if expiring soon)
            const token = await getValidAccessToken();
            if (!token) {
                logout();
                throw new Error('No valid token');
            }

            const response = await fetch(endpoint, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (!response.ok) {
                if (response.status === 401 && !retried) {
                    // Token might have expired, try to refresh
                    if (refreshToken) {
                        try {
                            await refreshTokens();
                            // Retry the request with new token
                            return apiFetch(endpoint, true);
                        } catch (e) {
                            console.error('Token refresh failed during API call:', e);
                            logout();
                            throw new Error('Session expired');
                        }
                    }
                    logout();
                    throw new Error('Unauthorized');
                }
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        }

        // Fetch API without triggering logout on auth failure (for background operations)
        async function apiFetchSilent(endpoint) {
            const token = await getValidAccessToken();
            if (!token) {
                throw new Error('No valid token');
            }

            const response = await fetch(endpoint, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            return response.json();
        }

        // =================================================================
        // Utility functions
        // =================================================================

        // Escape HTML special characters to prevent XSS
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Escape string for use in HTML attributes
        function escapeAttr(str) {
            if (!str) return '';
            return str.replace(/[&<>"']/g, c => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            })[c]);
        }

        // =================================================================
        // Runner WebSocket - Real-time WebSocket connection for runner events
        // Supports token refresh mid-connection without reconnecting
        // =================================================================
        class RunnerWebSocket {
            constructor() {
                this.ws = null;
                this.authenticated = false;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectAttempts = 0;
                this.reconnectTimer = null;
            }

            async connect() {
                // Close existing connection if any
                this.disconnect();

                try {
                    const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
                    this.ws = new WebSocket(`${protocol}//${location.host}/admin/ws`);

                    this.ws.onopen = async () => {
                        console.log('WebSocket connection established, sending auth...');
                        this.updateConnectionBadge('connecting');

                        // Send auth message - try to get fresh token, fall back to existing
                        let token = await getValidAccessToken();
                        if (!token) {
                            // getValidAccessToken failed (refresh error) - use existing token anyway
                            // Server will tell us if it's invalid via auth_error
                            token = accessToken;
                        }
                        if (!token) {
                            console.error('No token available for WebSocket auth');
                            this.ws.close();
                            return;
                        }
                        this.ws.send(JSON.stringify({ type: 'auth', token }));
                    };

                    this.ws.onmessage = async (event) => {
                        try {
                            const msg = JSON.parse(event.data);
                            await this.handleMessage(msg);
                        } catch (e) {
                            console.error('Failed to handle WebSocket message:', e);
                        }
                    };

                    this.ws.onerror = (event) => {
                        console.error('WebSocket error:', event);
                    };

                    this.ws.onclose = async (event) => {
                        console.log('WebSocket closed:', event.code, event.reason);
                        this.authenticated = false;
                        this.updateConnectionBadge(false);

                        // Don't reconnect if we closed intentionally (code 1000)
                        // or if logout was triggered
                        if (event.code !== 1000 && accessToken) {
                            await this.scheduleReconnect();
                        }
                    };
                } catch (e) {
                    console.error('Failed to establish WebSocket connection:', e);
                    await this.scheduleReconnect();
                }
            }

            async handleMessage(msg) {
                switch (msg.type) {
                    case 'auth_ok':
                        console.log('WebSocket authenticated');
                        this.authenticated = true;
                        this.reconnectDelay = 1000;
                        this.reconnectAttempts = 0;
                        this.updateConnectionBadge(true);
                        break;

                    case 'auth_error':
                        console.error('WebSocket auth error:', msg.message);
                        this.authenticated = false;
                        this.updateConnectionBadge(false);
                        // Don't logout - just try to refresh and reconnect.
                        // Server might have temporary issues (JWKS cache cold after restart).
                        // Only manual logout or page refresh with truly invalid tokens should logout.
                        if (refreshToken) {
                            try {
                                await refreshTokens();
                                // Try again with refreshed token
                                this.refreshAuth();
                            } catch (e) {
                                console.error('Token refresh failed, will retry on reconnect:', e);
                                // Schedule reconnect - don't logout, token might still be valid
                                this.scheduleReconnect();
                            }
                        } else {
                            // No refresh token - keep trying to reconnect anyway
                            this.scheduleReconnect();
                        }
                        break;

                    case 'state_snapshot':
                        console.log('Received state snapshot:', msg.runners.length, 'runners,', msg.models.length, 'models');
                        runnersState = msg.runners;
                        modelsState = msg.models;
                        statsState = msg.stats;
                        renderCurrentPage();
                        break;

                    case 'runner_connected':
                        console.log('Runner connected:', msg);
                        this.handleRunnerConnected(msg);
                        break;

                    case 'runner_disconnected':
                        console.log('Runner disconnected:', msg);
                        this.handleRunnerDisconnected(msg);
                        break;

                    case 'runner_status_changed':
                        console.log('Runner status changed:', msg);
                        this.handleRunnerStatusChanged(msg);
                        break;

                    case 'models_updated':
                        console.log('Models updated:', msg.models.length, 'models');
                        modelsState = msg.models;
                        renderModelsIfVisible();
                        break;

                    default:
                        console.log('Unknown WebSocket message type:', msg.type);
                }
            }

            async scheduleReconnect() {
                // Clear any existing reconnect timer
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                }

                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);
                console.log(`Scheduling WebSocket reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);

                // Try to refresh token before reconnecting
                if (refreshToken) {
                    try {
                        await refreshTokens();
                    } catch (e) {
                        console.error('Token refresh failed before WebSocket reconnect:', e);
                    }
                }

                this.reconnectTimer = setTimeout(() => {
                    this.reconnectTimer = null;
                    this.connect();
                }, delay);
            }

            // Re-authenticate with new token (called when token is refreshed)
            async refreshAuth() {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    const token = await getValidAccessToken();
                    if (token) {
                        console.log('Sending re-auth message to WebSocket');
                        this.ws.send(JSON.stringify({ type: 'auth', token }));
                    }
                }
            }

            disconnect() {
                // Clear reconnect timer
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }

                if (this.ws) {
                    this.ws.close(1000, 'Client disconnect');
                    this.ws = null;
                }
                this.authenticated = false;
                this.updateConnectionBadge(false);
            }

            updateConnectionBadge(connected) {
                const badge = document.getElementById('auto-refresh-badge');
                if (badge) {
                    if (connected === true) {
                        badge.textContent = 'Live';
                        badge.classList.remove('bg-yellow-100', 'text-yellow-800', 'bg-gray-100', 'text-gray-600');
                        badge.classList.add('bg-green-100', 'text-green-800');
                    } else if (connected === 'connecting') {
                        badge.textContent = 'Connecting...';
                        badge.classList.remove('bg-green-100', 'text-green-800', 'bg-gray-100', 'text-gray-600');
                        badge.classList.add('bg-yellow-100', 'text-yellow-800');
                    } else {
                        badge.textContent = 'Reconnecting...';
                        badge.classList.remove('bg-green-100', 'text-green-800', 'bg-gray-100', 'text-gray-600');
                        badge.classList.add('bg-yellow-100', 'text-yellow-800');
                    }
                }
            }

            handleRunnerConnected(data) {
                // Update local state
                const existingIndex = runnersState.findIndex(r => r.id === data.runner_id);
                const runner = {
                    id: data.runner_id,
                    name: data.name,
                    machine_type: data.machine_type,
                    health: data.health,
                    loaded_models: data.loaded_models,
                    is_online: true,
                    connected_at: new Date().toISOString(),
                    last_heartbeat: new Date().toISOString(),
                    mac_address: existingIndex >= 0 ? runnersState[existingIndex].mac_address : null,
                    http_base_url: null
                };

                if (existingIndex >= 0) {
                    // Preserve mac_address from existing offline runner
                    runner.mac_address = runnersState[existingIndex].mac_address;
                    runnersState[existingIndex] = runner;
                } else {
                    runnersState.push(runner);
                }

                // Update UI
                upsertRunnerCard(data.runner_id, runner);
                renderDashboardStats();
            }

            handleRunnerDisconnected(data) {
                // Update local state
                const runner = runnersState.find(r => r.id === data.runner_id);
                if (runner) {
                    runner.is_online = false;
                    runner.health = 'Offline';
                    runner.loaded_models = [];
                    runner.last_heartbeat = new Date().toISOString();
                }

                // Update UI
                markRunnerOffline(data.runner_id);
                renderDashboardStats();
            }

            handleRunnerStatusChanged(data) {
                // Update local state
                const runner = runnersState.find(r => r.id === data.runner_id);
                if (runner) {
                    runner.health = data.health;
                    runner.loaded_models = data.loaded_models;
                    runner.last_heartbeat = new Date().toISOString();
                }

                // Update UI
                updateRunnerCard(data.runner_id, {
                    health: data.health,
                    loaded_models: data.loaded_models
                });
            }
        }

        // Helper function to render a single runner card
        function renderRunnerCard(runner) {
            const safeId = escapeAttr(runner.id);
            const safeName = escapeHtml(runner.name);
            const safeHealth = escapeHtml(runner.health);
            const safeMachineType = escapeHtml(runner.machine_type || 'N/A');
            const safeMacAddress = escapeHtml(runner.mac_address || 'N/A');
            const safeHttpUrl = escapeHtml(runner.http_base_url || 'N/A');

            return `
                <div id="runner-card-${safeId}" class="rounded-lg shadow p-6 ${runner.is_online ? 'bg-white' : 'bg-gray-50 border border-gray-200'}" data-runner-id="${safeId}" data-is-online="${runner.is_online}" data-mac-address="${escapeAttr(runner.mac_address || '')}">
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <h3 class="text-lg font-medium ${runner.is_online ? 'text-gray-900' : 'text-gray-500'}">${safeName}</h3>
                            <p class="text-sm text-gray-500">${safeId}</p>
                        </div>
                        <div class="flex items-center space-x-2">
                            ${!runner.is_online && runner.mac_address ? `
                                <button onclick="wakeRunner('${safeId}')"
                                        class="inline-flex items-center rounded-md bg-blue-600 px-3 py-1 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                                        id="wake-btn-${safeId}">
                                    Wake
                                </button>
                            ` : ''}
                            <span class="runner-health-badge inline-flex items-center rounded-full px-3 py-1 text-sm font-medium ${
                                runner.health === 'Healthy' ? 'bg-green-100 text-green-800' :
                                runner.health === 'Degraded' ? 'bg-yellow-100 text-yellow-800' :
                                runner.health === 'Offline' ? 'bg-gray-100 text-gray-600' :
                                'bg-red-100 text-red-800'
                            }">${safeHealth}</span>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-4 text-sm">
                        <div>
                            <span class="text-gray-500">Machine Type:</span>
                            <span class="ml-2 ${runner.is_online ? 'text-gray-900' : 'text-gray-600'}">${safeMachineType}</span>
                        </div>
                        <div>
                            <span class="text-gray-500">MAC Address:</span>
                            <span class="ml-2 ${runner.is_online ? 'text-gray-900' : 'text-gray-600'}">${safeMacAddress}</span>
                        </div>
                        ${runner.is_online ? `
                            <div>
                                <span class="text-gray-500">HTTP URL:</span>
                                <span class="ml-2 text-gray-900">${safeHttpUrl}</span>
                            </div>
                            <div>
                                <span class="text-gray-500">Connected:</span>
                                <span class="ml-2 text-gray-900">${runner.connected_at ? new Date(runner.connected_at).toLocaleString() : 'N/A'}</span>
                            </div>
                        ` : ''}
                        <div>
                            <span class="text-gray-500">${runner.is_online ? 'Last Heartbeat' : 'Last Seen'}:</span>
                            <span class="ml-2 ${runner.is_online ? 'text-gray-900' : 'text-gray-600'}">${runner.last_heartbeat ? new Date(runner.last_heartbeat).toLocaleString() : 'N/A'}</span>
                        </div>
                    </div>
                    <div class="runner-models-section mt-4 ${runner.loaded_models && runner.loaded_models.length > 0 ? '' : 'hidden'}">
                        <span class="text-sm text-gray-500">Loaded Models:</span>
                        <div class="runner-models mt-1 flex flex-wrap gap-2">
                            ${(runner.loaded_models || []).map(m => `<span class="inline-flex items-center rounded-md bg-primary-100 px-2 py-1 text-xs font-medium text-primary-700">${escapeHtml(m)}</span>`).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Upsert (insert or update) a runner card
        function upsertRunnerCard(runnerId, runner) {
            const container = document.getElementById('runners-list');
            if (!container) return;

            const existingCard = document.getElementById(`runner-card-${runnerId}`);
            if (existingCard) {
                // Replace existing card
                existingCard.outerHTML = renderRunnerCard(runner);
            } else {
                // Check if we have the "No runners" message
                const noRunnersMsg = container.querySelector('.text-gray-500.text-center');
                if (noRunnersMsg) {
                    container.innerHTML = '';
                }
                // Insert new card at the top
                container.insertAdjacentHTML('afterbegin', renderRunnerCard(runner));
            }
        }

        // Mark a runner as offline (grey out and change badge)
        function markRunnerOffline(runnerId) {
            const card = document.getElementById(`runner-card-${runnerId}`);
            if (!card) return;

            // Update styling
            card.classList.remove('bg-white');
            card.classList.add('bg-gray-50', 'border', 'border-gray-200');
            card.dataset.isOnline = 'false';

            // Update name styling
            const nameEl = card.querySelector('h3');
            if (nameEl) {
                nameEl.classList.remove('text-gray-900');
                nameEl.classList.add('text-gray-500');
            }

            // Update health badge to Offline
            const badge = card.querySelector('.runner-health-badge');
            if (badge) {
                badge.className = 'runner-health-badge inline-flex items-center rounded-full px-3 py-1 text-sm font-medium bg-gray-100 text-gray-600';
                badge.textContent = 'Offline';

                // Add Wake button if runner has MAC address and button doesn't exist
                const macAddress = card.dataset.macAddress;
                const existingWakeBtn = card.querySelector(`#wake-btn-${runnerId}`);
                if (macAddress && !existingWakeBtn) {
                    const safeId = escapeAttr(runnerId);
                    const wakeBtn = `<button onclick="wakeRunner('${safeId}')"
                            class="inline-flex items-center rounded-md bg-blue-600 px-3 py-1 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                            id="wake-btn-${safeId}">
                        Wake
                    </button>`;
                    badge.insertAdjacentHTML('beforebegin', wakeBtn);
                }
            }

            // Hide loaded models section
            const modelsSection = card.querySelector('.runner-models-section');
            if (modelsSection) {
                modelsSection.classList.add('hidden');
            }
        }

        // Update a runner card's health and loaded models
        function updateRunnerCard(runnerId, updates) {
            const card = document.getElementById(`runner-card-${runnerId}`);
            if (!card) return;

            if (updates.health) {
                const badge = card.querySelector('.runner-health-badge');
                if (badge) {
                    badge.className = 'runner-health-badge inline-flex items-center rounded-full px-3 py-1 text-sm font-medium ' +
                        (updates.health === 'Healthy' ? 'bg-green-100 text-green-800' :
                         updates.health === 'Degraded' ? 'bg-yellow-100 text-yellow-800' :
                         updates.health === 'Offline' ? 'bg-gray-100 text-gray-600' :
                         'bg-red-100 text-red-800');
                    badge.textContent = updates.health;
                }
            }

            if (updates.loaded_models !== undefined) {
                const modelsSection = card.querySelector('.runner-models-section');
                const modelsContainer = card.querySelector('.runner-models');
                if (modelsSection && modelsContainer) {
                    if (updates.loaded_models.length > 0) {
                        modelsSection.classList.remove('hidden');
                        modelsContainer.innerHTML = updates.loaded_models
                            .map(m => `<span class="inline-flex items-center rounded-md bg-primary-100 px-2 py-1 text-xs font-medium text-primary-700">${escapeHtml(m)}</span>`)
                            .join('');
                    } else {
                        modelsSection.classList.add('hidden');
                    }
                }
            }
        }

        function showPage(page) {
            // Stop any existing refresh interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }

            currentPage = page;

            // Update nav
            document.querySelectorAll('.nav-link').forEach(el => {
                el.classList.remove('bg-gray-900', 'text-white');
                el.classList.add('text-gray-300', 'hover:bg-gray-700', 'hover:text-white');
            });
            const activeNav = document.getElementById(`nav-${page}`);
            if (activeNav) {
                activeNav.classList.add('bg-gray-900', 'text-white');
                activeNav.classList.remove('text-gray-300', 'hover:bg-gray-700', 'hover:text-white');
            }

            // Update title
            const titles = {
                dashboard: 'Dashboard',
                runners: 'Runners',
                models: 'Models',
                users: 'Users',
                requests: 'Requests'
            };
            document.getElementById('page-title').textContent = titles[page] || page;

            // Show page
            document.querySelectorAll('.page').forEach(el => el.classList.add('hidden'));
            document.getElementById(`page-${page}`).classList.remove('hidden');

            // Render current page from local state
            renderCurrentPage();
        }

        // Render the current page from local state (called on state updates)
        function renderCurrentPage() {
            if (!currentPage) return;

            // Update last-updated timestamp
            document.getElementById('last-updated').textContent = `Updated: ${new Date().toLocaleTimeString()}`;

            // Show/hide auto-refresh badge - all data now comes via WebSocket
            const badge = document.getElementById('auto-refresh-badge');
            if (['dashboard', 'runners', 'models'].includes(currentPage)) {
                badge.classList.remove('hidden');
                // Badge text is controlled by WebSocket connection state
            } else {
                badge.classList.add('hidden');
            }

            if (currentPage === 'dashboard') renderDashboard();
            else if (currentPage === 'runners') renderRunners();
            else if (currentPage === 'models') renderModels();
            else if (currentPage === 'users') loadUsers();
            else if (currentPage === 'requests') loadRequests();
            else if (currentPage === 'apikeys') loadApiKeys();
        }

        // Render dashboard stats from local state
        function renderDashboard() {
            renderDashboardStats();
        }

        // Update dashboard stats counters
        function renderDashboardStats() {
            const onlineCount = runnersState.filter(r => r.is_online).length;
            document.getElementById('stat-runners').textContent = onlineCount;
            document.getElementById('stat-users').textContent = statsState.total_users;
            document.getElementById('stat-requests').textContent = statsState.total_requests;
            document.getElementById('stat-requests-24h').textContent = statsState.requests_24h;
        }

        // Render runners list from local state
        function renderRunners() {
            const container = document.getElementById('runners-list');

            if (runnersState.length === 0) {
                container.innerHTML = '<div class="bg-white rounded-lg shadow p-6 text-gray-500 text-center">No runners registered</div>';
                return;
            }

            container.innerHTML = runnersState.map(runner => renderRunnerCard(runner)).join('');
        }

        // Render models list from local state
        function renderModels() {
            const ul = document.getElementById('models-ul');

            if (modelsState.length === 0) {
                ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">No models available</li>';
                return;
            }

            ul.innerHTML = modelsState.map(model => `
                <li class="px-4 py-4">
                    <div class="flex items-center justify-between">
                        <div>
                            <p class="text-sm font-medium text-gray-900">${escapeHtml(model.id)}</p>
                            <p class="text-xs text-gray-500">
                                ${model.quantization ? `Quant: ${escapeHtml(model.quantization)}` : ''}
                                ${model.context_length ? ` | Context: ${model.context_length}` : ''}
                                ${model.size_bytes ? ` | Size: ${(model.size_bytes / 1024 / 1024 / 1024).toFixed(1)} GB` : ''}
                            </p>
                        </div>
                        <div class="flex items-center space-x-3">
                            <span class="inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${
                                model.loaded ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-600'
                            }">${model.loaded ? 'Loaded' : 'Not loaded'}</span>
                            <span class="text-xs text-gray-500" title="Runners with model in memory">${model.runners.length} loaded</span>
                            <span class="text-xs text-gray-400" title="Runners with model on disk">${model.available_on ? model.available_on.length : 0} available</span>
                        </div>
                    </div>
                </li>
            `).join('');
        }

        // Render models if currently viewing models page
        function renderModelsIfVisible() {
            if (currentPage === 'models') {
                renderModels();
            }
            // Also update dashboard since model count might be relevant
            if (currentPage === 'dashboard') {
                renderDashboardStats();
            }
        }

        async function wakeRunner(runnerId) {
            const btn = document.getElementById(`wake-btn-${runnerId}`);
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Waking...';
            }

            try {
                const token = await getValidAccessToken();
                if (!token) {
                    logout();
                    return;
                }

                const response = await fetch(`/admin/runners/${encodeURIComponent(runnerId)}/wake`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                // Handle 401 with retry
                if (response.status === 401 && refreshToken) {
                    try {
                        await refreshTokens();
                        return wakeRunner(runnerId); // Retry
                    } catch (e) {
                        logout();
                        return;
                    }
                }

                const result = await response.json();

                if (response.ok && result.success) {
                    if (btn) {
                        btn.textContent = 'Sent!';
                        btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                        btn.classList.add('bg-green-600');
                    }
                    // Runner will appear via WebSocket when it connects
                } else {
                    alert(`Failed to wake runner: ${result.message}`);
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = 'Wake';
                    }
                }
            } catch (e) {
                console.error('Failed to wake runner:', e);
                alert('Failed to send wake request');
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Wake';
                }
            }
        }

        async function loadUsers() {
            const ul = document.getElementById('users-ul');
            ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">Loading users...</li>';

            try {
                const data = await apiFetch('/admin/api/users');

                if (data.users.length === 0) {
                    ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">No users found</li>';
                    return;
                }

                ul.innerHTML = data.users.map(user => `
                    <li class="px-4 py-4">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="text-sm font-medium text-gray-900">${escapeHtml(user.email || user.id)}</p>
                                <p class="text-xs text-gray-500">
                                    ID: ${escapeHtml(user.id)}
                                    | Created: ${new Date(user.created_at).toLocaleDateString()}
                                    | Last seen: ${new Date(user.last_seen_at).toLocaleDateString()}
                                </p>
                            </div>
                            <div class="flex items-center space-x-3">
                                <span class="text-sm text-gray-600">${user.request_count} requests</span>
                                <span class="inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${
                                    user.is_enabled ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                                }">${user.is_enabled ? 'Enabled' : 'Disabled'}</span>
                            </div>
                        </div>
                    </li>
                `).join('');
            } catch (e) {
                console.error('Failed to load users:', e);
                ul.innerHTML = '<li class="px-4 py-8 text-center text-red-500">Failed to load users</li>';
            }
        }

        let requestsPage = 1;
        let requestsTotalPages = 1;

        async function loadRequests(page = 1) {
            const ul = document.getElementById('requests-ul');
            ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">Loading requests...</li>';

            try {
                const data = await apiFetch(`/admin/api/requests?page=${page}&per_page=50`);
                requestsPage = data.page;
                requestsTotalPages = data.total_pages;

                if (data.requests.length === 0) {
                    ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">No requests found</li>';
                    return;
                }

                const requestsHtml = data.requests.map(req => `
                    <li class="px-4 py-4">
                        <div class="flex items-center justify-between">
                            <div class="flex-1 min-w-0">
                                <p class="text-sm font-medium text-gray-900 truncate">${escapeHtml(req.request_path)}</p>
                                <p class="text-xs text-gray-500">
                                    ${req.user_email ? escapeHtml(req.user_email) : escapeHtml(req.user_id.substring(0, 8) + '...')}
                                    ${req.client_ip ? `<span class="text-gray-400">from</span> ${escapeHtml(req.client_ip)}` : ''}
                                    <span class="text-gray-400">at</span> ${new Date(req.timestamp).toLocaleString()}
                                </p>
                                <p class="text-xs text-gray-400">
                                    ${req.model ? `Model: ${escapeHtml(req.model)}` : ''}
                                </p>
                            </div>
                            <div class="flex items-center space-x-3 ml-4">
                                ${req.latency_ms !== null ? `<span class="text-xs text-gray-500">${req.latency_ms}ms</span>` : ''}
                                ${req.tokens_prompt !== null || req.tokens_completion !== null ? `
                                    <span class="text-xs text-gray-500" title="Prompt / Completion tokens">
                                        ${req.tokens_prompt || 0} / ${req.tokens_completion || 0} tokens
                                    </span>
                                ` : ''}
                                <span class="inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${
                                    req.status === 200 ? 'bg-green-100 text-green-800' :
                                    req.status >= 400 ? 'bg-red-100 text-red-800' :
                                    'bg-gray-100 text-gray-600'
                                }">${req.status || 'pending'}</span>
                            </div>
                        </div>
                    </li>
                `).join('');

                // Add pagination controls if needed
                let paginationHtml = '';
                if (requestsTotalPages > 1) {
                    paginationHtml = `
                        <li class="px-4 py-3 bg-gray-50 flex items-center justify-between border-t">
                            <button onclick="loadRequests(${Math.max(1, requestsPage - 1)})"
                                    class="px-3 py-1 text-sm rounded ${requestsPage <= 1 ? 'text-gray-400 cursor-not-allowed' : 'text-primary-600 hover:bg-primary-50'}"
                                    ${requestsPage <= 1 ? 'disabled' : ''}>
                                Previous
                            </button>
                            <span class="text-sm text-gray-600">Page ${requestsPage} of ${requestsTotalPages}</span>
                            <button onclick="loadRequests(${Math.min(requestsTotalPages, requestsPage + 1)})"
                                    class="px-3 py-1 text-sm rounded ${requestsPage >= requestsTotalPages ? 'text-gray-400 cursor-not-allowed' : 'text-primary-600 hover:bg-primary-50'}"
                                    ${requestsPage >= requestsTotalPages ? 'disabled' : ''}>
                                Next
                            </button>
                        </li>
                    `;
                }

                ul.innerHTML = requestsHtml + paginationHtml;
            } catch (e) {
                console.error('Failed to load requests:', e);
                ul.innerHTML = '<li class="px-4 py-8 text-center text-red-500">Failed to load requests</li>';
            }
        }

        // ========== API Keys ==========

        let apiKeysLoaded = false;

        async function loadApiKeys() {
            const ul = document.getElementById('apikeys-ul');
            ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">Loading API keys...</li>';

            try {
                // Load users for the dropdown (if not already loaded)
                if (!apiKeysLoaded) {
                    await populateUserDropdown();
                    apiKeysLoaded = true;
                }

                const data = await apiFetch('/admin/api/keys');

                if (data.keys.length === 0) {
                    ul.innerHTML = '<li class="px-4 py-8 text-center text-gray-500">No API keys found. Create one above.</li>';
                    return;
                }

                const keysHtml = data.keys.map(key => `
                    <li class="px-4 py-4">
                        <div class="flex items-center justify-between">
                            <div class="flex-1 min-w-0">
                                <p class="text-sm font-medium text-gray-900">${escapeHtml(key.name)}</p>
                                <p class="text-xs text-gray-500">
                                    ${key.user_email ? escapeHtml(key.user_email) : escapeHtml(key.user_id.substring(0, 8) + '...')}
                                    <span class="text-gray-400">|</span> Created: ${new Date(key.created_at).toLocaleDateString()}
                                    ${key.last_used_at ? `<span class="text-gray-400">|</span> Last used: ${new Date(key.last_used_at).toLocaleString()}` : ''}
                                </p>
                            </div>
                            <div class="flex items-center space-x-3 ml-4">
                                ${key.revoked
                                    ? '<span class="inline-flex items-center rounded-full bg-red-100 px-2 py-1 text-xs font-medium text-red-800">Revoked</span>'
                                    : `<button onclick="revokeApiKey('${key.id}')" class="text-sm text-red-600 hover:text-red-800">Revoke</button>`
                                }
                            </div>
                        </div>
                    </li>
                `).join('');

                ul.innerHTML = keysHtml;
            } catch (e) {
                console.error('Failed to load API keys:', e);
                ul.innerHTML = '<li class="px-4 py-8 text-center text-red-500">Failed to load API keys</li>';
            }
        }

        async function populateUserDropdown() {
            try {
                const data = await apiFetch('/admin/api/users');
                const select = document.getElementById('api-key-user');
                select.innerHTML = '<option value="">Select a user...</option>';
                data.users.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.id;
                    option.textContent = user.email || user.id.substring(0, 8) + '...';
                    select.appendChild(option);
                });
            } catch (e) {
                console.error('Failed to load users for dropdown:', e);
            }
        }

        async function createApiKey() {
            const userId = document.getElementById('api-key-user').value;
            const name = document.getElementById('api-key-name').value.trim();

            if (!userId) {
                alert('Please select a user');
                return;
            }
            if (!name) {
                alert('Please enter a key name');
                return;
            }

            try {
                const data = await apiFetch('/admin/api/keys', {
                    method: 'POST',
                    body: JSON.stringify({ user_id: userId, name: name }),
                });

                // Show the secret key (only shown once!)
                document.getElementById('new-key-value').textContent = data.secret;
                document.getElementById('new-key-display').classList.remove('hidden');

                // Clear the form
                document.getElementById('api-key-user').value = '';
                document.getElementById('api-key-name').value = '';

                // Reload the list
                loadApiKeys();
            } catch (e) {
                console.error('Failed to create API key:', e);
                alert('Failed to create API key: ' + e.message);
            }
        }

        function copyApiKey() {
            const key = document.getElementById('new-key-value').textContent;
            navigator.clipboard.writeText(key).then(() => {
                alert('API key copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        async function revokeApiKey(keyId) {
            if (!confirm('Are you sure you want to revoke this API key? This cannot be undone.')) {
                return;
            }

            try {
                await apiFetch(`/admin/api/keys/${keyId}`, { method: 'DELETE' });
                loadApiKeys();
            } catch (e) {
                console.error('Failed to revoke API key:', e);
                alert('Failed to revoke API key: ' + e.message);
            }
        }

        // Handle hash-based navigation
        function getPageFromHash() {
            const hash = window.location.hash.slice(1); // Remove the #
            const validPages = ['dashboard', 'runners', 'models', 'users', 'requests', 'apikeys'];
            return validPages.includes(hash) ? hash : 'dashboard';
        }

        // Listen for hash changes (back/forward navigation)
        window.addEventListener('hashchange', () => {
            if (accessToken) {
                showPage(getPageFromHash());
            }
        });

        // Initialize on page load
        init();
    </script>
</body>
</html>
